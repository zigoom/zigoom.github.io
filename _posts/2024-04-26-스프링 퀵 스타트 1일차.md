---
title: 스프링 퀵 스타트 1일차
author: jonghoon
date: 2024-04-26 18:00:00 +09:00
categories: [Study, S_Spring, 스프링 퀵 스타트]
tags: [Spring, book]
toc: true
comments: true
---
  

### **2.1 프레임워크 개념**  
#### **2.1.1 프레임워크 배경**
  - 여러명의 사람들이 개발을 할때 아키텍처의 일관성을 유지해서 유지보수을 쉽게 하기위해서 만듬

#### **2.1.2 프레임워크 장점**
  - 분석,설계,구현 등에서 재사용성이 증가한다.
  - 빠른 구현 시간, 쉬운 관리, 개발자의 열량 획일화, 검증된 아키텍처 재사용 및 일관성 유지

#### **2.1.3 자바 기반 프레임워크 (p31)**
  - 자바 기반이라 오픈소스 형태로 라이선스 비용이 없음  
  - Presentation   
    - Struts     : UI Layer 중점의 MVC 프레임워크  
    - Spring(MVC): Struts 처럼 MVC 로 작동하지만 Spring 프레임워크에 들어있음     
  - Business
    - Spring(IoC, AOP) : 스프링이 가진 IoC와 AOP를 이용하여 비즈니스 컴포넌트 개발
  - Presistence 
    - Hibernate, JPA  : Hibernate는 ORM(Object Relation Mapping) 프레임 워크로 자체적으로 SQL를 프레임워크가 생성하여 DB연동을 한다. JPA는 Hibernate를 포함한 ORM의 공통인터페이스 제공 자바표준 API
    - Ibatis, Mybatis : SQL 명령어와 자바객체(VO,DTO)를 매핑하는 기능
				
### **2.2 스프링 프레임워크**

#### **2.2.1 스프링 탄생 배경 (p32)**
  - 2004에 만든 오픈소스 프레임워크, 이전에는 EJB(Enterprise Java Beans)로 개발하였으나 EJB는 복잡하고 학습이 시간이 필요하여 개발,유지보수가 힘들다. 그리고 WAS(Web Application server) 장비가 필요한데 JEUS,Weblogic,WebSphere 등 대부분 장비들이 수천만원의 고가장비이다.
  - 스프링 프레임워크는 POJO(Plain Old JAva Object)로 옛날의 자바 객체를 이용한다는 뜻이며, 이의 반대로는 Servlet 클래스가 있다. (p33)

#### **2.2.2 스프링 프레임워크 특징 (p34)**
  - IoC와 AOP를 지원하는 경량 컨테이너 프레임워크
   - **(1) 경량(Lightweight)**
     - 여러개의 모듈로 구성되어 JAR 파일로 구성되어 있고, POJO형태로 객체를 관리하고 있어 클래스에 대한 특별한 규칙이 없어 가볍다.
   - **(2) 제어의 역행(Inversion of Control)** 
     - IoC를 통해서 자바코드를 컨테이너가 처리해 줘서 객체간의 낮은 결합도를 유지한다. (p35)
   - **(3) 관점지향 프로그래밍(Aspect Oriented Programming, AOP)** 
     - 비즈니스 코드를 공통로직으로 분리해서 응집도가 높은 비즈니스 컴포넌트를 만들고, 유지보수를 향상
   - **(4) 컨테이너(Container)** 
     - 객체의 생성과 관리를 담당하고,객체 운용에 필요한 기능을 제공한다.

### **2.3 IoC(Inversion of Control) 컨테이너 (p36)**
- 서블릿을 상속을 받아서 서블릿 클래스를 만들고 이를 web.xml에 해당 클래스를 등록한다.후에 서블릿을 실행하면 해당 클래스를 객체로 만들어서 호출을 하게되면서 해당 클래스에 있는 doGet() 메소드를 호출해준다.

#### **2.3.1 결합도(Coupling)가 높은 프로그램**
#### **2.3.2 다향성 이용**
  - 다향성을 이용하기 위해서 상속과 메소드 재정의, 형변환을 사용한다.

#### **2.3.3 디자인 패턴 사용**
  - Factory패턴이 적용된 BeanFactory 클래스를 사용하여 객체를 만들어서 반환되도록 만들수 있다.(p45)

### **3.1 스프링 IoC(Inversion of Control)**
#### **3.1.1 스프링 설정 파일 (p49)**  
  - applicationContext.xml 에서 bean에 자신이 만든 빈클래스를 등록한다.
  - main() 에서 ApplicationContext 객체를 생성하고, 팩토리를 만들어서 내가 원하는 객체를 요청하여 해당 메소드를 실행할 수 있다.

#### **3.1.3 스프링 컨테이너 (p54)**
  - ApplicationContext는 BeanFactory 를 상속하고 있다.
  - BeanFactory은 스프링에서 bean 객체를 생성하고 관리하며, 
	사용자가 요청할때 객체가 생성되어 지연로딩(lazy loading) 방식을 사용한다.  (일반적인 스프링 프로젝트에서는 사용하지 않을예정)
  - ApplicationContext는 상속받은 내용 + 트랜젝션 관리, 메시지 기반 다국어 처리등을 자원한다.  
	컨테이너가 구동시에 bean에 등록된 클래스를 객체로 생성하여 즉시 로딩처리(pro-loading)를 한다.
  - 웹 애플리케이션 개발을 지원하고 있다.

### **3.2 스프링 XML 설정**
#### **3.2.1 \<beans\> 루트 엘리먼트**
  - bean의 생명주기를 관리하는 서비스
  - applicationContext.xml에 보면 spring-beans.xsd 문서를 등록하고 있는데 여기에는
	\<bean\>, \<description\>, \<alias\>, \<import\> 가 자식으로 되어있다.

#### **3.2.2 \<import\> 엘리먼트 (p57)**
  - 트랜잭션 관리, 예외처리, 다국어 처리 등의 다른 파일로 나누어진 파일을 하나로 통합할때 사용

#### **3.2.3 \<bean\> 엘리먼트**
  - 위에 \<beans\> 는 최상위에서 정의하는 부분이고, 여기서는 bean 클래스를 등록하고, id를 정의한다.
	(id는 생략 가능 class는 필수, 하지만 요청이 되려면 id가 있어야 하며 공백없는 카멜표기법으로 만든다.)
  - id와 같은기능으로 name도 있으며, 여기서는 카멜을 안써도 된다.

#### **3.2.4 \<bean\> 엘리먼트 속성**
  - init-method 를 이용하여 해당 클래스를 초기화 해준다. (클래스에 내부 함수 호출)
  - destroy-method 는 해당컨테이너를 제거하기 전에 호출한다.
  - ApplicationContext을 이용할때는 lazy-init을 이용해서 사용량이 적은데 메모리를 많이 먹는 경우 해당
	객체를 호출할때 생성하도록 설정 할 수 있다.
  - scope을 사용하면 사용 범위를 지정하여 싱글톤으로 사용 할 수 있다. scope을 prototype으로 하면 요청때마다 객체를 새로 만든다.

### **4.1 의존성 관리하는**
#### **4.1.1 스프링 의존성 관리**
  - 스프링은 IoC(제어의 역행)의 핵심 원리로 객체의 생성과 의존관계를 컨테이너가 자동으로 관리한다.
  - Dependency Lookup : 컨테이너가 운영에 필요한 객체를 생성하고 사용자가 객체를 검색하는 방식
  - Dependency Injection : 객체 사이의 의존관계를 스프링에 설정에 등록된 정보로 컨테이너가 자동으로 처리 (의존설정을 바꾸고 싶다면 설정 파일을 수정하여 유지보수 향상)
  - 컨테이너에서 처리할때 Setter 메소드 기반인 세터 인젝션(Setter Injection)과 생성자 기반 생성자 인젝션(Constructor Injection)이 있다.

#### **4.1.2 의존성 관계 (p66)**
  - 의존성 관계는 객체와 겍체의 결합에 대한 관계로 다른 객체의 변수나 메소드를 이용해야 한다면 이를 의존하고 있는것이다.

### **4.2 생성자 인젝션 사용**
 - 클래스의 생성자를 추가하는데 이때 인자를 반드시 받는 형식으로 한다. 그리고 그 인자를 특정 클래스로 지정을 해서 보내면
	해당 클래스에 대한 의존성 주입 처리를 쉽게 할 수 있다.
 - 인자로 받아드릴 클래스는 applicationContext.xml에서 \<bean\>의 속성으로 \<constructor-arg\>로 지정할 수 있다.
   (물론 해당 인자로 받아드릴 클래스 역시 bean으로 선언되어 있어야 한다) (p71)
 - 스프링 컨테이너에서 bean에 등록된 객체를 생성할떄는 xml 상에서 위에서부터 순서대로 만들어 지는데 이때 생성자 인젝션으로 의존성이 주입되면(즉 arg 값으로 생성시에 필요한 객체일 경우에는) 해당 생성자 보다 먼저 생성되게 된다.

#### **4.2.1 다중 변수 매핑**
  - 위에서는 한개의 변수를 인자로 받아서 처리했는데 여러개도 가능하다 (클래스가 아닌 값도 처리 가능) 

### **4.3 Setter 인젝션**
 - setter를 이용해서 의존성을 주입하는데 대부분 이 방식을 사용하고, 사용이 힘들경우에 생성자 인젝션을 사용한다.
   (우리가 아는 getter/setter 매소드를 이용해서 주입하는 방식이다.)
 - applicationContext.xml 에서 \<bean\>에 인자로 \<property\>를 사용하면 setter 인젝션으로 주입할수 있다. (p82)

#### **4.3.2 p 네임스페이스**
  - \<beans\>에서 추가해 주고, \<bean\>에서 p: 으로 값을 전달해 준다. (p85 참조)  
 
### **4.4 컬랙션(Collection) 객체**
#### **4.4.1 List (p86 - p87)**
#### **4.4.2 Set 은 중복값을 허용하지 않는다. (p88)**
#### **4.4.3 Map 은 Key로 데이터를 등록 한다. (p90)** 
#### **4.4.4 Properties key=value 형태 (p91)**

### **5.1 어노테이션**
#### **5.1.1 ApplicationContext.xml 에서 Context 네이스페이스 추가**
#### **5.1.2 컴포넌트 스탠(component-scan) (p94)**
 - 컴포넌트 스탠(component-scan) 을 추가하면 @Component를 쓴 클래스들을 자동으로 객체 생성 (이때 패키지를 지정해서 해당 패키지 하위에 있는것만 처리할 수도 있다)

#### **5.1.3 @Component (p97)**
 - 이제 @Component를 클래스에 적어주면 Bean으로 등록안해도 자동으로 처리된다.  
  (기본 생성자 필요, @Componentd()에 이름기입 필요)

#### **5.2.1 어노테이션으로 의존성 주입**
  - @Autowired : 주로 변수에 설정 해당 타입의 객체를 자동으로 할당
  - @Qualifier : 특정 객체 이름으로 의존성 주입
  - @Injection : @Autowired와 동일한 기능
  - @Resource  : @Autowired + @Qualifier 합한 기능

#### **5.2.2 @Autowired**
  - 생성자, 메소드, 멤버변수 모두 사용 가능, 대부분 멤버변수에 사용. 
  - 해당 타입이 메모리에 있는지 혹인후에 변수 주입, 없으면 오류를 발생 (p99)
  
#### **5.2.3 @Qualifier**
  - 의존 주입 대상의 타입 객체가 2개 이상일 경우 사용하여 의존대상을 명시한다.

#### **5.2.4 @Resource**
  - @Autowired + @Qualifier 둘다 사용 가능하며 name을 이용해서 주입도 가능.

#### **5.2.5 어노테이션, XML 의존성 병행**
  - 의존성을 주입할때 두개를 병행 사용하는것은 가능하다
  - 라이브러리 형태로 제공하고 있다면 xml로 설정해 줘야 한다.
 
#### **5.3.1 추가 어노테이션**
  - @Service : 비즈니스 로직 처리 Service 클래스
  - @Repository : 데이터 베이스 연동 DAO 클래스
  - @Controller : 사용자 요청 제어 Controller 클래스
 
### **6.2 Value Object 클래스**
 - VO(Value Object) : 레이어와 레이어 사이에 데이터를 한번에 주고 받을 목적의 클래스 DTO(Data Transfer Object)라고도는데 데이터 전달을 목적으로 한다. (Getter/Setter, toString을 사용)

### **6.3 DAO 클래스**
 - DAO(Data Access Object) : 데이터베이스 연동을 담당하는 클래스, CRUD(Create, Read, Update, Delete) 기능을 구현하며, JDBC 드라이버가 필요하다.

#### **6.3.2 JDBC Uility 클래스**
  - Mybatis 같은 프레임 워크를 사용하지 않는다면 DB 연동을 편하게 하기 위해서 DAO에서 공통으로 사용할 JDBCUtil 클래스를 만들어서 사용.

### **6.4 ~ 6.5 Service 인터페이스 및 구현 클래스**
 - DAO를 호출하여 DB에 내용을 불러오라고 시키는 서비스 기능을 정의하는 부분이다. 
 - 컨트롤러에서 서비스에 요청하면 서비스는 DAO를 호출하여 VO 형테로 데이터를 받아서 다시 반환한다.
 
  